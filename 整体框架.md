# PX4整体架构设计

![ | 500](asset/Pasted%20image%2020230701161831.png)

PX4系统主要由 [飞行控制栈](##飞行控制栈) 和 [中间件](##中间件) 组成。飞行控制栈包括了从传感器数据采集到控制律和执行器最终执行的全流程组件集合，该部分也包括了多种无人机构型（例如固定翼、旋翼和VTOL）姿态估计、控制算法等，主要负责驱动无人机的飞行。中间件包含了多种应用层组件，例如传感器驱动程序和外部应用程序，负责整合内/外部通讯和软硬件资源，支持多种类型的无人机和应用程序。

整体来看，PX4系统架构与APM软件架构最大的差异在于，PX4的整个系统采用了 [响应式](http://www.reactivemanifesto.org/) 设计，所有部件都被分割成为**独立的模块**，各个功能组件都能够任意替换、组合、复用，模块之间采用**异步的消息队列**进行通讯，使得各个模块之间充分解耦，系统能够**应对不同的工作负载**。

## 顶层架构

![[asset/Pasted image 20230610011523.png|600]]

PX4的设计从大角度划分为五个部分：
1. 数据存储（Storage）
2. 外部通讯（External Connectivity）
3. 驱动程序（Drivers）
4. 飞行控制（Flight Control）
5. 消息总线（Message Bus）

### 数据存储（Storage）

数据存储分为3个部分：

1、飞行任务存储部分（dataman）：dataman给上层应用提供了可以随时存储指定飞行任务的通用函数，上层应用可以通过调用dm_write和dm_read函数来读写飞行任务，通常用于读写飞行航迹点的坐标。保存的目标通常在sdcard中。

2、飞机参数存储部分（param）：飞控程序中定义了大量的飞行参数，例如，与串级PID控制参数就有二十多个，用于其它功能的参数还有很多，程序中提供了param_get和param_set函数可以将这些参数存放到flash和sdcard中。

3、飞行日志存储部分（logger）：飞控程序中提供了两种飞行日志的记录方式（二选一），早期的日志记录方式为sdlog2，可以将需要记录的数据用字符方式存储到sdcard中的csv格式文件中，飞行结束后可以通过其它的软件程序来查看。近期的飞控程序推荐使用logger来记录飞行日志，它可以将飞控程序中的uORB记录下来并保存（关于uORB我们会城后续章节中详细讲述）。

### 二、外部通讯（External Connectivity）

飞控程序的外部通讯采用的是Mavlink协议，Mavlink是无人机外部通讯的一个轻量级通讯协议。与外部通讯即是与计算机上的地面站程序来进行通讯。我们可以使用Mavlink官方提供的协议生成工具来定制我们自己需要的协议内容，并可以通过需要生成不同编程语言所使用的源文件，例如C/C++、Java、Python等。这样的好处是同样的一个通讯协议可以被飞控程序、PC计算机、手机APP程序和其它程序同时使用。这样就有效的避免了不同运行平台上，不同类型程序运行的差异，而采用相同的协议通讯。

### 三、驱动程序（Drivers）

驱动程序是飞控程序中采集传感器数据的源头，常用的传感器驱动程序有：

1、相机驱动：通常可以控制相机的拍照功能，并可以对其指定拍照参数，例如：光圈、快门、感光度、焦距、白平衡、曝光补偿等等。这些控制功能主要取决于相机的功能。对于最初级拍照相机来说，飞控程序只需要对其发送“拍照”命令即可。

2、GPS驱动：全球定位系统（Global Positioning System）的驱动程序。在前面系列中我们已经讲述过，在室外的自动飞行过程中无人机需要执行定点飞行模式，然而定点飞行模式的前提就是要有GPS数据对IMU的积分数据进行修正，所以GPS是自动飞行功能的基础，它通常有ashtech、mtk和u-blox等。驱动程序中会根据当前插入的GPS协议进行自动切换并解析。

3、遥控器驱动：目前常见的遥控器通讯协议为SBUS和PPM，就实用性来说SBUS通讯协议可能更高一点，但其从电路上需要接入一个反向器（Pixhawk上已经加入了反向器），通常采用串口来传输SBUS协议，串口波特率100k，其支持16个遥控器通道，而每一个通道的数值采用11个bit位来表示即 `11*16=176` 字节，基格式如下：

```
[startbyte][data1][data2]……[data22][flags][endbyte]

startbyte=0x0f

endbyte=0x00
```

4、云台驱动：云台通常安装在多旋翼机架正下方，在云台上挂载相机或其它设备。云台通常有自己的软件程序，可以很好的达到自平衡的状态。也就是说，当飞机产生俯仰或滚转角度时，云台会自动修正其三轴（简易云台通常只有两个转动轴）舵机的角度从而自动恢复平衡。而飞控程序也可以通过向云台发送相关指令控制其当前俯仰、滚转、航向角度。

5、空速计、数传、光流、距离传感器等：这些传感器驱动并不是在所有的飞机上都要使用，通常根据实际需要来使用其中的一个或几个。空速计可以测量当前空气流动速度；数传支持无线传输设备的数据发送与接收；光流定位系统驱动可以检测当前移动速度与位置；距离传感器可以检测传感器前方物体与其之间的距离，例如：超声波、雷达、双目摄像头、激光测距仪等等。

6、IMU传感器驱动：IMU传感器是飞控驱动程序中最重要的部分，其通过初始化、校准、读取加速计、陀螺仪、磁罗盘这些传感器，为上层状态融合和导航系统提供最基本的数据支撑。加速计是检测飞机当前三轴的加速度，陀螺仪可以检测飞机的旋转角速度，而为了消除陀螺仪的航向积分误差，需要使用磁罗盘对其做航向修正。IMU的数据采集的频率通常都高于其它的驱动程序，通常是250Hz。

### 四、飞行控制（Flight Control）

1、传感器数据集成（Sensors Hub）：sensors模块收取了所有传感器的数据，包括加速计、陀螺仪、磁罗盘、空速计、高度计、电量计等等传感器的读数，并对这些数据进行初步过滤与处理。之后将处理后的数据向ekf2模块发送。

2、姿态位置估计（Position Attitude Estimator）：ekf2中主要对传感器的数据进行融合，并采用卡尔曼滤波对其做进一步的处理，进而对飞机当前的姿态和位置做出估计。

3、状态机（State Machine）：commander处理飞机当前状态（正常、异常）和用户命令。在多种状态下切换。例如：飞控锁定/解锁、飞机模式切换、安全保护启动与关闭、启动传感器或遥控器校准功能等等。

4、自动飞行（Autonomous Flight）：navigator配合dataman中存储的任务信息进行自动飞行功能，给定飞机当前的飞行目标点（将位置期望传递给位置控制模块），并以指定高度和航向飞行，到达目标点执行特定任务（例如：拍照、鸣笛等），并继续向下一点飞行。

5、位置控制（Position Controller）：串级PID反馈控制，外环PID将当前期望位置输出为期望速度，内环PID根据期望速度计算出期望姿态，输出给姿态控制模块。

6、姿态控制（Attitude Rate）：串级PID反馈控制，外环PID将当前期望状态输出为期望角速度，内环PID根据期望角速度计算出期望控制量，输出给控制输出模块。

7、控制输出（Output Driver）：得到姿态控制最终输出的控制量，根据机型不同机型（四轴、六轴、八轴等）Mixer混控文件，输出实际多路控制PWM信号，输出到电调中，实现电机的控制。

### 五、消息总线（Message Bus）

飞控程序中内部消息传递采用的是异步消息机制**uORB**。它的设计理念很有趣，它可以实现不同模块中的数据快速通讯，并且以异步通讯为基本原则，也就是说在通讯过程中发送者只负责发送数据，而并不关心数据由谁接收，也不关心接收者是否能将所有的数据都接收到；而对于接收者来说并不关心数据是由谁发送的，也不关心在接收过程中是否将所有数据都接收到。

uORB在数据发布与接收过程中并不保证发送者的所有数据都可以被接收者收到，而只保证接收者在想要接收时能收到最新的数据。而发送与接收的分离可以使飞程中各个模块相互独立，互不干扰。实际上一个uORB可以由多个发送者发布，也可以被多个接收者接收。

## 飞行控制栈

飞行控制栈是自主无人机的制导、导航和控制算法的集合。它包括固定翼、多旋翼和垂直起降机身的控制器以及姿态和位置的估计器。包含输入（Sensors、RC），估计器，导航、位置、姿态控制器，混合器、执行器。

![](asset/Pasted%20image%2020230701160028.png)

**估计器 Estimator** 读取多个传感器输入，根据数据计算无人机的高度和姿态。

**控制器 Controller** 将设定值和测量值或估计状态作为输入，调整过程变量的值与设定值匹配，使输出达到该设定值。

**混合器 Mixer** 接收控制器命令（语义化的命令），将其转换为特定的设备上的操作命令（实际控制设备运转的命令，如电机转速），同时确保不找过某些限制。

## 中间件

发布/订阅模式的轻量级进程/线程间通信组件。具体查看 [uORB](uORB.md)。

# 运行时环境

- **NuttX**：是一个开源的RTOS，提供了 Posix API。
- **任务 （Tasks）**: 模块在它自己的任务中运行, 具有自己的堆栈和进程优先级（在 Nuttx 中 Task 就是线程）。
- **工作队列（WorkQueue）** 
	- 所有任务都必须合作，因为它们不能相互干扰。
	- 可以在一个队列上运行多个工作队列任务，并且可以有多个队列。
	- 通过指定将来的固定时间或通过 uORB 主题更新回调来调度工作队列任务。
	- 多个模块共享使用工作队列能够减少RAM消耗，并且导致更少的任务切换。
	- 缺点是工作队列不能执行长时间的任务，例如休眠、阻塞 IO等。

> [!note] 
> 
> 在 Linux 或 macOS 平台，PX4 作为一个单独的进程运行，模块在各个线程中运行。

# 项目文件说明

> [!todo]
> 拆分项目文件，按层级或功能划分列出项目中模块说明。

# 资料链接

[^1]: Pixhawk 二次开发指南 https://www.zhihu.com/question/38874663