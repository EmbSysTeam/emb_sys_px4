# uORB 概述

![ | 300](asset/Pasted%20image%2020230701162033.png)

uORB（Micro Object Request Broker）即轻量级对象请求代理，是一个用于抽象设备驱动和数据对象的代理中间件，它为数据分发提供了相应的数据结构。uORB的消息传递机制遵循一对多的“发布-订阅”设计模式，发布者将共享的信息公布给一个话题（topic），该topic定义了一个包含相关语义的消息通道，例如飞行姿态“vehicle_attitude”、LED灯的状态“led_control”、安全开关状态“safety”等。订阅者能够订阅一个topic，以任意一个设定的频率轮询更新数据，也允许在所订阅的topic发布新数据时唤醒。

发布-订阅的设计模式分离了状态更新的执行方和使用数据的执行方，它们可以独立存在于不同的模块中，也可以在相同的上下文中工作，如上图所示。

uORB消息定义：uORB消息传递使用二进制消息格式表示，为了保证不同模块之间能够以相同的字段解码消息内容，uORB使用特定格式的标记语言声明消息的字段和类型。由于不同的平台硬件差异和编译器之间的差异，直接使用消息结构体定义消息内容可能导致代码在不同平台上表现出不一致的行为，这对于控制诸如PWM输出、电机旋转等具有一定危险性的设备来说是难以接受的。即使消息内容能够被解码，如果数据类型或数据表示的错误也可能给硬件提供一个不合理的输出值，消息定义保证了数据表示的唯一性，并且保持了一致的内存对齐要求。

uORB消息代码生成工具：uORB定义的消息会生成相应的字段声明、序列化格式和一个全局唯一的消息ID。序列化格式为消息解码提供了类型检查，字段声明使得消息具有自明性，不需要提供消息的定义格式。全局唯一的消息ID将被用于进程间订阅、发布的唯一标识。

uORB的topic被实现为一个虚拟文件，它允许多个监听者并行地阻塞等待接口的响应，发布的读写锁允许多个发布者高效地并发执行，并确保对整个topic内容读写的原子性。由于发布-订阅的隔离，订阅者能够独立设定对数据更新频率，而不受发布者的更新频率影响。异步和阻塞等待方法与操作系统的任务优先级设置相结合，可以在控制管道中实现最小延迟和确定性调度。

![ | 300](asset/Pasted%20image%2020230701174008.png)

- uORB::DeviceNode是topic虚拟节点的具体表现形式，它继承自cdev::CDev，即字符设备（Character Device）的抽象表示，用于处理字符数据流设备，例如串口、终端等外设。因此，uORB::DeviceNode可以看作是专用于进程间通信的虚拟字符设备，它与Nuttx内核中的其他cdev设备相同，它向注册了文件打开、关闭、读取、IO控制相关的操作函数，并将该虚拟字符设备与uORB消息topic绑定。此外，作为订阅-发布机制的底层组件，为上层组件提供了节点注册、查找、查询、数据队列缓冲区、poll相关状态维护等接口。

- uORB::DeviceMaster为uORB消息通信的主设备节点，它被实现为一个单例类，它负责管理和协调全局的uORB topic的发布和订阅操作。DeviceMaster为DeviceNode的注册提供相应句柄（handle），模块通过句柄发送和接受消息，并且接管了订阅关系管理工作，用于检查订阅发布关系、维护数据缓冲区、实时性和优先级控制。

- uORB::Manager以上则为用户提供uORB通信的编程接口，Publication和Subscription封装了消息数据和uORB::Manager提供的API，为用户提供语义化的、便于使用的对象。uORB::Manager与uORB::DeviceMaster一样实现为单例类，负责管理uORB topic的实例，与uORB::DeviceMaster的区别在于，uORB::Manager负责提供更高层次的topic模块间通信的功能，而非管理DeviceNode本身。

# 代码实现

> [!todo]

# 可能有用的链接

[^1]: uORB 发布/订阅图 https://docs.px4.io/main/en/middleware/uorb_graph.html