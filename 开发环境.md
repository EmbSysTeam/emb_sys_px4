# 开发环境搭建

工具链安装在 [官方文档](https://docs.px4.io/main/zh/dev_setup/dev_env.html) 中有详细介绍。下文主要提供一个使用docker快速搭建开发环境的流程，对系统环境的破坏性较小。

Overview：
- Host 平台使用Linux。
- Docker使用PX4官方提供的 Ubuntu [镜像](https://hub.docker.com/u/px4io)。
	- [NuttX交叉编译环境的镜像](https://hub.docker.com/r/px4io/px4-dev-nuttx-focal/tags)
	- [使用模拟器的编译环境镜像](https://hub.docker.com/r/px4io/px4-dev-simulation-focal/tags)
- 模拟器使用 Gazebo 或 Gazebo Ignition。
- Host环境安装 [QGC地面站](https://docs.qgroundcontrol.com/master/en/releases/daily_builds.html)。
- 代码编辑器使用 [VSCode](https://docs.px4.io/main/zh/dev_setup/vscode.html)。

主机平台使用 Linux 更方便在 Docker 中启动 GUI 程序，因为 Linux 平台使用 [X server](https://wiki.archlinux.org/title/xorg) 显示图形界面，只需要将主机 X server 的 unix套接字 挂载到 Docker 容器内就能显示容器中的 GUI 程序。

> X server 是一种 C/S 架构的 [显示服务器](https://en.wikipedia.org/wiki/Windowing_system#Display_server)，客户端和服务器使用 [unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 连接。与 Windows 相比，它运行在内核之上，应用程序作为客户端将数据发送到显示服务器，显示服务器将数据写入帧缓冲，并使用驱动程序将内容渲染到显示器。

> [!todo] Windows平台在Docker中启动GUI程序
> 
> - [ ] WSL中使用Docker[^1]
> - [ ] Windows运行容器中的GUI程序[^2]

# 安装步骤

1. **clone 代码仓库**

```shell
$ git clone https://github.com/PX4/PX4-Autopilot.git --branch release/1.13
```

代码仓库使用最近的稳定版 [v1.13](https://github.com/PX4/PX4-Autopilot/tree/release/1.13)，使用master分支可能引入不必要的错误。另外需要注意的是，clone 仓库没有使用 `--recursive` 递归 clone 子模块，cmake 中提供了 [添加子模块的脚本](https://github.com/PX4/PX4-Autopilot/blob/release/1.13/cmake/px4_git.cmake)，在 build 时会检查没有初始化的子模块，并进行 clone。

> 本项目修改后的代码在 fork仓库的 [learning](https://github.com/EmbSysTeam/PX4-Autopilot/tree/learning) 分支。该分支主要用于学习PX4代码，内容不限于添加注释、更改文档、修正代码、提交新代码等。

2. **启动 docker**

首先拉取 docker 镜像，以带有模拟器环境的 docker 镜像为例。该镜像使用 Ubuntu 20.04(focal)。该镜像安装了 Gazebo classic、Gazebo Ignition、jMAVSim 等模拟器，不包含交叉编译工具链。

```shell
$ docker pull px4io/px4-dev-simulation-focal:latest
```

启动 docker 容器。

``` bash
$ docker run -it --privileged \
	--user root \
    -v /path/to/PX4-Autopilot:/root/PX4-Autopilot:rw \
    -v /tmp/.X11-unix:/tmp/.X11-unix:ro \
    -e DISPLAY=$DISPLAY \
    --network host \
    px4io/px4-dev-simulation-focal bash
```

其中：
- `-it`： 启动 tty 交互。
- `--privileged`：赋予权限，允许访问主机设备。
- `--user root`：非必要，dockerfile 中没有设置用户 ID 和组 ID，无法使用 apt 安装软件时开启。
- `-v /path/to/PX4-Autopilot:/root/PX4-Autopilot:rw`：将主机clone的代码库挂载到 docker 容器中。
- `-v /tmp/.X11-unix:/tmp/.X11-unix:ro`：挂载显示服务器的 unix 套接字。
- `-e DISPLAY=$DISPLAY`：指定显示设备。
- `--network host`：使用 host 网络模式，docker 容器内网络使用主机网络，便于连接位于主机上的地面站。

禁用 X server 的访问控制，允许 docker 显示服务器连接。

```shell
$ xhost +
```

3. **安装必要工具**

-  [VSCode](https://docs.px4.io/main/zh/dev_setup/vscode.html)

VSCode中首先安装 [Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) 用于管理主机上可用的容器，在 VSCode 中 `Attach` 选择的容器即可打开环境。

![ | 300](asset/Pasted%20image%2020230701115032.png)

在容器中安装推荐扩展，主要推荐安装的扩展有：
- CMake
- CMake Tools
- clangd
- Cortex-Debug
其余推荐扩展在 Recommended 中查看。

代码提示工具使用的是 [llvm clangd](https://clangd.llvm.org/)，而没有使用 [微软 C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) 扩展。clangd 是一个 [语言服务器 LSP](https://learn.microsoft.com/en-us/visualstudio/extensibility/language-server-protocol?view=vs-2022)，它使用编译工具（如CMake）生成的 `compile_commands.json` 编译命令指导代码提示。相比于  [微软 C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) 扩展，它能够提供更快速、更精确的代码提示，可配置性也更高。

要让 clangd 扩展正常工作，需要正确配置 `Clangd:Arguments`，可供参考的配置如下：

```json
{
	...
	"clangd.arguments": [
        "--all-scopes-completion",
        "--compile-commands-dir=build/px4_sitl_default",
        "--completion-style=bundled",
        "--completion-parse=auto",
        "--cross-file-rename",
        "--header-insertion-decorators",
        "--background-index",
        "--clang-tidy",
        "--enable-config",
        "--fallback-style=Google",
        "-j=2",
        "--pch-storage=memory",
        "--function-arg-placeholders=false",
        "--header-insertion=never"
    ],
	...
}
```

其中 `--compile-commands-dir=build/px4_sitl_default` 参数指定了 clangd 搜索 `compile_commands.json` 文件的位置，更改该参数需要执行 `clangd: Restart language server` VSCode 命令以使其生效。其他参数请参考 `clangd --help` 。

- 安装 [QGC地面站](https://docs.qgroundcontrol.com/master/en/releases/daily_builds.html)

4. **初次编译**

```shell
# 启动Gazebo classic
$ make px4_sitl gazebo

# 启动 Gazebo Ignition
$ make px4_sitl ignition
```

配置 QGC 连接。模拟器中无人机会监听 UDP 14550 端口，如果在 docker 中没有使用 `host` 网络模式，IP 地址需要更改为 172.17.0.2。
![ | 500](asset/Pasted%20image%2020230701123539.png)

编译完成后启动界面如下所示。

![](asset/Pasted%20image%2020230701122650.png)

> [!seealso] 
> 
> 如果要在 [模拟器的编译环境镜像](https://hub.docker.com/r/px4io/px4-dev-simulation-focal/tags) 中编译 NuttX 的代码，可以安装交叉编译工具链。
> 
> ```shell
> $ apt install gcc-arm-none-eabi
> 
> $ arm-none-eabi-gcc -v
> # ... 
> # gcc version 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] (15:9-2019-q4-0ubuntu1)
> ```
> 
> - [ ] 该编译器版本的程序未进行烧录测试

# 测试第一个程序

> [!todo] 文档待完善
> 
> 1. https://docs.px4.io/main/zh/modules/hello_sky.html
> 2. https://github.com/EmbSysTeam/PX4-Autopilot/tree/learning/src/examples/my_example

# 提交代码

为了保留一个清晰的提交记录，向 learning 分支提交代码需要先建立一个独立分支，在独立分支做出更改后推送到代码仓库，然后发起 [PR（Pull requests）](https://github.com/EmbSysTeam/PX4-Autopilot/pulls) 合并代码，merge 请求请使用 `Squash and merge`，详细步骤查看 [Github Docs](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request)。

> [!note]
> 
> 在使用 git push 前，请使用 [rebase](https://docs.github.com/en/get-started/using-git/using-git-rebase-on-the-command-line) 将本地代码与远程仓库进行同步。
> 
> *一句话了解 rebase：变基操作，将目标仓库的提交记录放在你本地提交记录之前，你本地的提交记录将被放置在更新的代码仓库之后，因此使用 rebase 操作也需要你先解决远端仓库和你本地仓库的合并冲突。*
> 
> ```shell
> $ git fetch
> $ git pull --rebase origin learning
> 
> # 如果存在合并冲突，解决合并冲突
> $ git rebase --continue
> 
> # 没有冲突就可以push了
> $ git push
> ```

# 可能有帮助的资料链接

[^1]: https://docs.docker.com/desktop/wsl/
[^2]: https://dev.to/darksmile92/run-gui-app-in-linux-docker-container-on-windows-host-4kde